[
  {
    "id": "1",
    "title": "Async race condition in search results",
    "publishedAt": "Feb 10, 2026",
    "readTime": "2 min",
    "banner": "https://res.cloudinary.com/frontendddlab/image/upload/v1770710099/poster_nrye8c.png",
    "sourceLink": "https://github.com/sumittttpaul/FrontendLab/blob/master/src/app/practice/async-race-condition-in-search-results/page.tsx",
    "keywords": ["async race condition", "react state", "frontend edge case", "ui correctness", "search"],
    "content": [
      {
        "type": "heading",
        "value": "Problem"
      },
      {
        "type": "description",
        "value": "Under rapid input changes and slow network conditions, multiple search requests can remain in flight at the same time. When responses resolve out of order, older results may overwrite newer state, causing the UI to display incorrect data."
      },
      {
        "type": "description",
        "value": "The implementation assumes that the most recent request will resolve last. This assumption breaks under real-world network latency and asynchronous execution."
      },
      {
        "type": "point",
        "value": [
          "Multiple async requests in flight simultaneously.",
          "Variable or throttled network latency.",
          "Rapid user input before previous requests resolve.",
          "State updates tied directly to promise resolution."
        ]
      },
      {
        "type": "code",
        "value": "useEffect(() => {\n  if (!query.trim()) return;\n\n  void (async () => {\n    try {\n      const data = await fetchResults(query);\n      console.log(\"commit results for:\", query);\n      setResults(data);\n    } catch (error) {\n      console.error(\"search request failed\", error);\n    }\n  })();\n}, [query]);",
        "path": "src/app/practice/async-race-condition-in-search-results/page.tsx"
      },
      {
        "type": "description",
        "value": "This implementation works in happy paths but does not guard against out-of-order async resolution. Any response that resolves later is allowed to update state, regardless of when it was initiated."
      },
      {
        "type": "video",
        "value": "https://res.cloudinary.com/frontendddlab/video/upload/v1770708401/broken_gpijkg.mp4",
        "thumbnail": "https://res.cloudinary.com/frontendddlab/image/upload/v1770709385/thumbnail_lhsulr.png"
      },
      {
        "type": "spacing",
        "value": ""
      },
      {
        "type": "heading",
        "value": "Solution"
      },
      {
        "type": "description",
        "value": "Each request is assigned an identity, and state updates are only allowed from the most recent request. Responses that resolve out of order are ignored instead of committing stale data."
      },
      {
        "type": "code",
        "value": "const requestIdRef = useRef(0);\n\nuseEffect(() => {\n  if (!query.trim()) {\n    requestIdRef.current = 0;\n    return;\n  }\n\n  const requestId = ++requestIdRef.current;\n\n  void (async () => {\n    try {\n      const data = await fetchResults(query);\n      if (requestId === requestIdRef.current) {\n        console.log(\"commit results for:\", query);\n        setResults(data);\n      } else {\n        console.log(\"ignored stale response for:\", query);\n      }\n    } catch (error) {\n      console.error(\"search request failed\", error);\n    }\n  })();\n}, [query]);",
        "path": "src/app/practice/async-race-condition-in-search-results/page.tsx"
      },
      {
        "type": "description",
        "value": "By guarding state updates with request identity, the UI becomes resilient to async timing differences and network variability."
      },
      {
        "type": "video",
        "value": "https://res.cloudinary.com/frontendddlab/video/upload/v1770708403/fixed_smxrnq.mp4",
        "thumbnail": "https://res.cloudinary.com/frontendddlab/image/upload/v1770709385/thumbnail_lhsulr.png"
      },
      {
        "type": "separator",
        "value": ""
      },
      {
        "type": "description",
        "value": "This issue is not specific to search, debouncing, or React. It occurs whenever UI state is updated directly from asynchronous work without guarding against out-of-order resolution. Treating async responses as untrusted by default and committing state only when intent is still valid prevents an entire class of UI correctness bugs."
      }
    ]
  },
  {
    "id": "2",
    "title": "State update after unmount during navigation",
    "publishedAt": "Feb 10, 2026",
    "readTime": "2 min",
    "banner": "https://res.cloudinary.com/frontendddlab/image/upload/v1770735145/banner_h5rvad.png",
    "sourceLink": "https://github.com/sumittttpaul/FrontendLab/blob/master/src/app/practice/state-update-after-unmount-during-navigation/page.tsx",
    "keywords": ["react unmount bug", "state update after unmount", "frontend lifecycle", "async ui failure", "navigation teardown"],
    "content": [
      {
        "type": "heading",
        "value": "Problem"
      },
      {
        "type": "description",
        "value": "When a component starts asynchronous work and the user navigates away before it resolves, the async callback may still attempt to update state. At that point, the component no longer exists in the UI tree."
      },
      {
        "type": "description",
        "value": "This failure usually appears only under fast navigation or slow async resolution, making it easy to miss during development and code review."
      },
      {
        "type": "point",
        "value": [
          "Async work initiated inside an effect.",
          "User navigates away before async resolves.",
          "Component unmounts while async is still running.",
          "Async callback commits state after unmount."
        ]
      },
      {
        "type": "code",
        "value": "useEffect(() => {\n  console.log(\"[BROKEN] Screen mounted → async work started\");\n\n  void (async () => {\n    await delay(800);\n    console.log(\"[BROKEN] Async finished → updating screen\");\n    setStatus(\"loaded\");\n  })();\n\n  return () => {\n    console.log(\"[BROKEN] Screen unmounted\");\n  };\n}, []);",
        "path": "src/app/practice/state-update-after-unmount-during-navigation/page.tsx"
      },
      {
        "type": "description",
        "value": "The async task has no awareness of the component lifecycle. Once started, it continues executing even after the component has been removed from the UI."
      },
      {
        "type": "spacing",
        "value": ""
      },
      {
        "type": "heading",
        "value": "Solution"
      },
      {
        "type": "description",
        "value": "Each effect execution is assigned an ownership identity. Cleanup invalidates that ownership, and async work is only allowed to commit state if its ownership is still valid."
      },
      {
        "type": "code",
        "value": "const effectIdRef = useRef(0);\n\nuseEffect(() => {\n  const effectId = ++effectIdRef.current;\n  console.log(\"[FIXED] Screen mounted → ownership id:\", effectId);\n\n  void (async () => {\n    await delay(800);\n\n    if (effectId !== effectIdRef.current) {\n      console.log(\"[FIXED] Async finished → ownership no longer valid, update skipped:\", effectId);\n      return;\n    }\n\n    console.log(\"[FIXED] Async finished → ownership valid, screen updated:\", effectId);\n    setStatus(\"loaded\");\n  })();\n\n  return () => {\n    if (effectIdRef.current === effectId) {\n      effectIdRef.current = -1;\n    }\n    console.log(\"[FIXED] Screen unmounted → ownership invalidated:\", effectId);\n  };\n}, []);",
        "path": "src/app/practice/state-update-after-unmount-during-navigation/page.tsx"
      },
      {
        "type": "description",
        "value": "Instead of relying on mount flags, the async work validates ownership before committing state. Cleanup explicitly invalidates intent, making teardown safe even under rapid navigation."
      },
      {
        "type": "video",
        "value": "https://res.cloudinary.com/frontendddlab/video/upload/v1770735137/broken_fixed_uaka7w.mp4",
        "thumbnail": "https://res.cloudinary.com/frontendddlab/image/upload/v1770735144/thumbnail_vcaz4d.png"
      },
      {
        "type": "separator",
        "value": ""
      },
      {
        "type": "description",
        "value": "This issue is not about React warnings or effect cleanup syntax. It occurs whenever asynchronous work is allowed to outlive the UI intent that created it. Treating async callbacks as untrusted unless their ownership is still valid prevents state leaks, memory issues, and subtle UI corruption during navigation."
      }
    ]
  },
  {
    "id": "3",
    "title": "Stale closure in click outside listener",
    "publishedAt": "Feb 13, 2026",
    "readTime": "2 min",
    "banner": "https://res.cloudinary.com/frontendddlab/image/upload/v1770993341/banner_v77iew.png",
    "sourceLink": "https://github.com/sumittttpaul/FrontendLab/blob/master/src/app/practice/stale-closure-in-click-outside-listener/page.tsx",
    "keywords": ["stale closure", "react event listener bug", "click outside issue", "frontend state safety", "ui correctness"],
    "content": [
      {
        "type": "heading",
        "value": "Problem"
      },
      {
        "type": "description",
        "value": "Event listeners defined inside effects capture state from the render during which they were created. If the listener is attached once and depends on state that later changes, it may continue operating on outdated values."
      },
      {
        "type": "point",
        "value": [
          "Dropdown open state toggled by button.",
          "Document click listener attached once on mount.",
          "Listener captures initial 'open' value.",
          "UI state and listener logic fall out of sync."
        ]
      },
      {
        "type": "code",
        "value": "useEffect(() => {\n  function handleClick(event: MouseEvent) {\n    console.log(\"[BROKEN] listener sees open =\", open);\n\n    const target = event.target as Node;\n    const isOutside =\n      containerRef.current &&\n      !containerRef.current.contains(target);\n\n    if (open && isOutside) {\n      console.log(\"[BROKEN] closing dropdown\");\n      setOpen(false);\n    }\n  }\n\n  document.addEventListener(\"click\", handleClick);\n\n  return () => {\n    document.removeEventListener(\"click\", handleClick);\n  };\n}, []);",
        "path": "src/app/practice/stale-closure-click-outside/page.tsx"
      },
      {
        "type": "description",
        "value": "Because the effect runs only once, the event listener permanently captures the initial value of 'open'. The dropdown state changes visually, but the listener continues evaluating stale state."
      },
      {
        "type": "video",
        "value": "https://res.cloudinary.com/frontendddlab/video/upload/v1770993344/broken_bxya01.mp4",
        "thumbnail": "https://res.cloudinary.com/frontendddlab/image/upload/v1770993341/thumbnail_broken_j3guxg.png"
      },
      {
        "type": "spacing",
        "value": ""
      },
      {
        "type": "heading",
        "value": "Solution"
      },
      {
        "type": "description",
        "value": "Keep the event listener stable, but separate state freshness from subscription lifecycle. Store the latest state in a mutable ref and read from it inside the listener."
      },
      {
        "type": "code",
        "value": "const openRef = useRef(open);\nconst containerRef = useRef<HTMLDivElement | null>(null);\n\nuseEffect(() => {\n  openRef.current = open;\n}, [open]);\n\nuseEffect(() => {\n  function handleClick(event: MouseEvent) {\n    const target = event.target as Node;\n    const isOutside =\n      containerRef.current &&\n      !containerRef.current.contains(target);\n\n    console.log(\"[FIXED] click detected | openRef:\", openRef.current, \"| outside:\", isOutside);\n\n    if (openRef.current && isOutside) {\n      console.log(\"[FIXED] closing dropdown\");\n      setOpen(false);\n    }\n  }\n\n  document.addEventListener(\"click\", handleClick);\n\n  return () => {\n    document.removeEventListener(\"click\", handleClick);\n  };\n}, []);",
        "path": "src/app/practice/stale-closure-click-outside/page.tsx"
      },
      {
        "type": "description",
        "value": "The listener remains attached only once, preventing unnecessary re-subscriptions. State freshness is handled independently through a ref, ensuring the dropdown logic always evaluates the latest value without closure drift."
      },
      {
        "type": "video",
        "value": "https://res.cloudinary.com/frontendddlab/video/upload/v1770993345/fixed_nk5soq.mp4",
        "thumbnail": "https://res.cloudinary.com/frontendddlab/image/upload/v1770993341/thumbnail_fixed_lwmgpl.png"
      },
      {
        "type": "separator",
        "value": ""
      },
      {
        "type": "description",
        "value": "Closures capture values at creation time. When subscriptions remain stable but state changes over time, logic may silently operate on outdated data. Separating subscription stability from state freshness prevents subtle UI inconsistencies and aligns event handling with real user behavior."
      }
    ]
  }
]
