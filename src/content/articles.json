[
  {
    "id": "1",
    "title": "Async race condition in search results",
    "publishedAt": "Feb 10, 2026",
    "readTime": "2 min",
    "banner": "https://res.cloudinary.com/frontendddlab/image/upload/v1770710099/poster_nrye8c.png",
    "sourceLink": "https://github.com/sumittttpaul/FrontendLab/blob/master/src/app/practice/async-race-condition-in-search-results/page.tsx",
    "keywords": ["async race condition", "react state", "frontend edge case", "ui correctness", "search"],
    "content": [
      {
        "type": "heading",
        "value": "Problem"
      },
      {
        "type": "description",
        "value": "Under rapid input changes and slow network conditions, multiple search requests can remain in flight at the same time. When responses resolve out of order, older results may overwrite newer state, causing the UI to display incorrect data."
      },
      {
        "type": "description",
        "value": "The implementation assumes that the most recent request will resolve last. This assumption breaks under real-world network latency and asynchronous execution."
      },
      {
        "type": "point",
        "value": [
          "Multiple async requests in flight simultaneously.",
          "Variable or throttled network latency.",
          "Rapid user input before previous requests resolve.",
          "State updates tied directly to promise resolution."
        ]
      },
      {
        "type": "code",
        "value": "useEffect(() => {\n  if (!query.trim()) return;\n\n  void (async () => {\n    try {\n      const data = await fetchResults(query);\n      console.log(\"commit results for:\", query);\n      setResults(data);\n    } catch (error) {\n      console.error(\"search request failed\", error);\n    }\n  })();\n}, [query]);",
        "path": "src/app/practice/async-race-condition-in-search-results/page.tsx"
      },
      {
        "type": "description",
        "value": "This implementation works in happy paths but does not guard against out-of-order async resolution. Any response that resolves later is allowed to update state, regardless of when it was initiated."
      },
      {
        "type": "video",
        "value": "https://res.cloudinary.com/frontendddlab/video/upload/v1770708401/broken_gpijkg.mp4",
        "thumbnail": "https://res.cloudinary.com/frontendddlab/image/upload/v1770709385/thumbnail_lhsulr.png"
      },
      {
        "type": "spacing",
        "value": ""
      },
      {
        "type": "heading",
        "value": "Solution"
      },
      {
        "type": "description",
        "value": "Each request is assigned an identity, and state updates are only allowed from the most recent request. Responses that resolve out of order are ignored instead of committing stale data."
      },
      {
        "type": "code",
        "value": "const requestIdRef = useRef(0);\n\nuseEffect(() => {\n  if (!query.trim()) {\n    requestIdRef.current = 0;\n    return;\n  }\n\n  const requestId = ++requestIdRef.current;\n\n  void (async () => {\n    try {\n      const data = await fetchResults(query);\n      if (requestId === requestIdRef.current) {\n        console.log(\"commit results for:\", query);\n        setResults(data);\n      } else {\n        console.log(\"ignored stale response for:\", query);\n      }\n    } catch (error) {\n      console.error(\"search request failed\", error);\n    }\n  })();\n}, [query]);",
        "path": "src/app/practice/async-race-condition-in-search-results/page.tsx"
      },
      {
        "type": "description",
        "value": "By guarding state updates with request identity, the UI becomes resilient to async timing differences and network variability."
      },
      {
        "type": "video",
        "value": "https://res.cloudinary.com/frontendddlab/video/upload/v1770708403/fixed_smxrnq.mp4",
        "thumbnail": "https://res.cloudinary.com/frontendddlab/image/upload/v1770709385/thumbnail_lhsulr.png"
      },
      {
        "type": "separator",
        "value": ""
      },
      {
        "type": "description",
        "value": "This issue is not specific to search, debouncing, or React. It occurs whenever UI state is updated directly from asynchronous work without guarding against out-of-order resolution. Treating async responses as untrusted by default and committing state only when intent is still valid prevents an entire class of UI correctness bugs."
      }
    ]
  }
]
